<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: README
  
    &mdash; Documentation by YARD 0.9.26
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "README";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><p><img src="https://raw.githubusercontent.com/realtradam/FelECS/master/logos/felecs-logo-text.png" alt="FelECS"></p>

<!-- ![FelECS](https://filestorage.catgirls.rodeo/images/felflame-logo-smaller-text.png) -->

<p><a href="https://codeclimate.com/github/realtradam/FelECS/maintainability"><img src="https://api.codeclimate.com/v1/badges/56d425d9078e98efb74b/maintainability" alt="Maintainability"></a>
<a href="https://codeclimate.com/github/realtradam/FelECS/test_coverage"><img src="https://api.codeclimate.com/v1/badges/56d425d9078e98efb74b/test_coverage" alt="Test Coverage"></a>
<a href="http://inch-ci.org/github/realtradam/FelECS"><img src="http://inch-ci.org/github/realtradam/FelECS.svg?branch=master" alt="Inline docs"></a>
<a href="https://github.com/realtradam/FelECS/blob/master/LICENSE"><img src="https://img.shields.io/github/license/realtradam/FelECS?label=license&style=flat" alt="MIT License"></a>
<a href="https://ko-fi.com/tradam"><img src="https://img.shields.io/static/v1?message=Buy%20me%20a%20coffee&logo=kofi&labelColor=ff5e5b&color=434B57&logoColor=white&label=%20" alt="Ko-Fi"></a></p>

<p><strong><a href="https://felflame.tradam.fyi/">Check out the comprehensive documentation here!</a></strong></p>

<hr>

<!-- vim-markdown-toc GFM -->

<ul>
<li><a href="#what-is-felecs">What is FelECS?</a></li>
<li><a href="#what-is-ecs">What is ECS?</a>
    * <a href="#components">Components</a>
    * <a href="#entities">Entities</a>
    * <a href="#systems">Systems</a>
    * <a href="#scenes">Scenes</a>
    * <a href="#stage">Stage</a>
    * <a href="#order">Order</a></li>
<li><a href="#usage">Usage</a>

<ul>
<li><a href="#entities-1">Entities</a>

<ul>
<li><a href="#creation">Creation</a></li>
<li><a href="#accessing">Accessing</a></li>
<li><a href="#adding-and-removing-components">Adding and Removing Components</a></li>
<li><a href="#accessing-entities-attached-components">Accessing Entities&#39; Attached Components</a></li>
<li><a href="#deletion">Deletion</a></li>
</ul></li>
<li><a href="#components-1">Components</a>

<ul>
<li><a href="#creating-a-component-manager">Creating a Component Manager</a></li>
<li><a href="#creating-a-component-from-a-component-manager">Creating a Component from a Component Manager</a></li>
<li><a href="#accessing-1">Accessing</a></li>
<li><a href="#accessing-attributes-and-changing-them">Accessing Attributes and Changing Them</a></li>
<li><a href="#deleting-components">Deleting Components</a></li>
<li><a href="#accessing-components-attached-entities">Accessing Components&#39; attached Entities</a></li>
</ul></li>
</ul></li>
<li><a href="#get-the-first-entity-attached">get the first entity attached.</a></li>
<li><a href="#this-will-throw-a-warning-if-there-is-more-or-less-then">this will throw a warning if there is more or less then</a></li>
<li><a href="#exactly-one-entity">exactly one entity</a>

<ul>
<li><a href="#systems-1">Systems</a>

<ul>
<li><a href="#creation-1">Creation</a></li>
</ul></li>
</ul></li>
<li><a href="#code-and-logic">Code and Logic</a></li>
<li><a href="#do-something-with-these-components">do something with these components</a>
    * <a href="#execution">Execution</a>
    * <a href="#alternative-execution">Alternative Execution</a></li>
<li><a href="#when-this-component-is-added-to-an-entity-this-system-will-be-called">When this Component is added to an Entity, this System will be called</a></li>
<li><a href="#when-this-component-is-removed-from-an-entity-this-system-will-be-called">When this Component is removed from an Entity, this System will be called</a></li>
<li><a href="#when-this-components-health-attribute-is-changed-this-system-will-be-called">When this Component&#39;s health attribute is changed, this System will be called</a></li>
<li><a href="#when-a-component-from-this-component-manager-is-added-to-an-entity-this-system-will-be-called">When a Component from this Component Manager is added to an Entity, this System will be called</a></li>
<li><a href="#when-a-component-from-this-component-manager-is-removed-from-an-entity-this-system-will-be-called">When a Component from this Component Manager is removed from an Entity, this System will be called</a></li>
<li><a href="#when-this-components-health-attribute-from-this-component-manager-is-changed-this-system-will-be-called">When this Component&#39;s health attribute from this Component Manager is changed, this System will be called</a>
    * <a href="#clearing-alternative-executions">Clearing Alternative Executions</a></li>
<li><a href="#clears-all-triggers-with-this-system">clears ALL triggers with this system</a></li>
<li><a href="#clears-all-triggers-with-this-component-manager">clears ALL triggers with this Component Manager</a></li>
<li><a href="#clear-the-trigger_when_added-for-this-component">clear the &#39;trigger_when_added&#39; for this Component</a></li>
<li><a href="#clear-the-trigger_when_removed-for-this-component">clear the &#39;trigger_when_removed&#39; for this Component</a></li>
<li><a href="#clear-the-trigger_when_is_set-for-this-component-specifically-for-the-health-attribute">clear the &#39;trigger_when_is_set&#39; for this Component specifically for the health attribute</a></li>
<li><a href="#clears-all-triggers-with-this-component">clears ALL triggers with this Component</a></li>
<li><a href="#clear-the-trigger_when_added-for-this-component-manager">clear the &#39;trigger_when_added&#39; for this Component Manager</a></li>
<li><a href="#clear-the-trigger_when_removed-for-this-component-manager">clear the &#39;trigger_when_removed&#39; for this Component Manager</a></li>
<li><a href="#clear-the-trigger_when_is_set-for-this-component-manager-specifically-for-the-health-attribute">clear the &#39;trigger_when_is_set&#39; for this Component Manager specifically for the health attribute</a>
    * <a href="#redefinition">Redefinition</a></li>
<li><a href="#some-new-logic-or-code">Some new logic or code</a>

<ul>
<li><a href="#scenes-1">Scenes</a>

<ul>
<li><a href="#creation-2">Creation</a></li>
<li><a href="#accessing-2">Accessing</a></li>
<li><a href="#adding-systems">Adding Systems</a></li>
<li><a href="#removing-systems">Removing Systems</a></li>
<li><a href="#clearing">Clearing</a></li>
<li><a href="#execution-1">Execution</a></li>
</ul></li>
<li><a href="#stage-1">Stage</a>

<ul>
<li><a href="#adding-scenes">Adding Scenes</a></li>
<li><a href="#removing-scenes">Removing Scenes</a></li>
<li><a href="#executing">Executing</a></li>
</ul></li>
<li><a href="#order-1">Order</a>

<ul>
<li><a href="#setting-the-order">Setting the order</a></li>
</ul></li>
<li><a href="#closing-notes">Closing Notes</a></li>
</ul></li>
<li><a href="#contribution">Contribution</a></li>
</ul>

<!-- vim-markdown-toc -->

<h1 id="what-is-felecs">What is FelECS?</h1>

<pre class="code ruby"><code class="ruby">FelECS is an ECS framework for developing games in the Ruby language. FelECS has been designed from the ground up with these three ideas in mind:

1. **Engine Agnostic:** FelECS has been designed to be rendering engine agnostic as long as the target rendering engine is written in Ruby. This means that this framework can be dropped into existing rendering engines such as [Ruby2D](http://www.ruby2d.com) or [DRGTK](https://dragonruby.org/toolkit/game) with little modifications.
2. **Easily Extensible:** FelECS has been designed such that extensions to its capabilities can be easily added. Extensions such as rendering engine wrappers, premade systems, premade components, etcetera can be easily coded and then distributed as gems.
3. **Principle of (My) Least Astonishment:** I want to develop games using a language and framework I love and makes sense to me, inspired by the [Philosophy of the creator of Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language)#Philosophy).
</code></pre>

<h1 id="what-is-ecs">What is ECS?</h1>

<pre class="code ruby"><code class="ruby">ECS is a software architectural pattern that is used in video game development. Traditionally games were programmed using an object oriented method, while ECS instead attempts to program games using a data oriented method instead.  
ECS stands for Entity, Component, and System.

---
</code></pre>

<h3 id="components">Components</h3>

<pre class="code ruby"><code class="ruby">This is where the data or information of a given &quot;object&quot; is stored. There is no logic or code here. 
</code></pre>

<h3 id="entities">Entities</h3>

<pre class="code ruby"><code class="ruby">Entities will contain one or more Components, but contains no logic or data otherwise
</code></pre>

<h3 id="systems">Systems</h3>

<pre class="code ruby"><code class="ruby">Systems are where all the logic or code is kept. There is no data stored in here.

---

By using this pattern it allows programmers to easily control what an &quot;object&quot; or entity can do and how much data it needs to have. It avoids the issue of inhertance as no inhertance is ever required in this system. If you need a certain entity to have a certain functionality you just add the relevant component to it, and the systems that automatically go over specific components will give your entitiy the desired functionality.  

**&quot;But your framework also has `Scenes`, `Stage`, and `Order`, what is that about?&quot;**  

---
</code></pre>

<h3 id="scenes">Scenes</h3>

<pre class="code ruby"><code class="ruby">Scenes are simply a collection or subset of Systems. This allows for an easy way to activate and deactivate Systems.
</code></pre>

<h3 id="stage">Stage</h3>

<pre class="code ruby"><code class="ruby">The Stage is Scenes which are activated. This means any Scenes on the Stage are executed each frame, while the rest of the Systems are not.
</code></pre>

<h3 id="order">Order</h3>

<pre class="code ruby"><code class="ruby">Order is a helper class which can set the priority of Scenes and Systems.

---
</code></pre>

<h1 id="usage">Usage</h1>

<pre class="code ruby"><code class="ruby">There are 2 ways of using FelECS. You can either `include` it as a gem in your project if your game engine supports this. The other option is to download the single file export of FelECS and then `require_relative` this file in your project. The single file export takes all the ruby code in the various files and concatenates them into a single file so it is more portable and easy to add.

To use the gem method you can do the following: install the gem using `gem install felflame` or using bundler `bundle add felflame` and then require it in your project like so: `require &#39;felflame&#39;`.

To use the single file export method you simply download the felflame.rb file from the [releases page on Github](https://github.com/realtradam/FelECS/releases) and add it to your source folder and add a `require relative &#39;felflame.rb&#39;` line or wherever you have placed the file to use it.
</code></pre>

<h2 id="entities">Entities</h2>

<h3 id="creation">Creation</h3>

<pre class="code ruby"><code class="ruby">Entities are essentially &quot;objects&quot; in the game world. To create a new Entity we do the following:

```ruby
@entity = FelECS::Entities.new
```
or if we want to add (any number of)components to it when creating it:

```ruby
</code></pre>

<p>@entity = FelECS::Entites.new(
        FelECS::Components::Health.new,
        @component,
        FelECS::Components::EnemyTeam.first
        )
    ```</p>

<h3 id="accessing">Accessing</h3>

<pre class="code ruby"><code class="ruby">Oftentimes you will not be accessing an Entity this way. Later we will shows you a more common way of accessing entities.
If you need to you can access Entities using the `Entities` module:

```ruby
@entity = FelECS::Entities[2]
@entity = FelECS::Entities.first
@entity = FelECS::Entities.each # you can iterate over all entities this way. Any valid array method can be used
```
</code></pre>

<h3 id="adding-and-removing-components">Adding and Removing Components</h3>

<pre class="code ruby"><code class="ruby">We can still add or remove Components from an Entity after it has been created. Here is how:

```ruby
@entity.add @component
@entity.remove @component
```
</code></pre>

<h3 id="accessing-entities-attached-components">Accessing Entities&#39; Attached Components</h3>

<pre class="code ruby"><code class="ruby">This is the most common way of accessing an Entity

When Components are added to Entities, they can be accessed from the Entity. By using a Component Manager as a key we can access an array of all components created from that Component Manager that are attached to an entity:

```ruby
@entity.components[@component_manager] # =&gt; [@component1, @component2, @component3]
```
</code></pre>

<h3 id="deletion">Deletion</h3>

<pre class="code ruby"><code class="ruby">To have all Components from an Entity **removed** and the Entity deleted we do the following:

NOTE: The components will **not be deleted**. They are simply **removed** from the entity and then the entity is destroyed. You must handle component deletion yourself as for example singleton components need to removed instead of deleted.

```ruby
@entity.delete
```
</code></pre>

<h2 id="components">Components</h2>

<h3 id="creating-a-component-manager">Creating a Component Manager</h3>

<pre class="code ruby"><code class="ruby">Components are where all the data is stored. The data is stored in variables or accessors in each component.
These accessors and their defaults are configured when a component manager is created, like so:

```ruby
@component_manager = FelECS::Components.new(&#39;Stats&#39;, :armour, hp: 100)
```

In this example we created a component manager called &quot;Stats&quot;.
The name given to component managers must follow the same rules for naming constants in ruby for a reason you will shortly see.
The parameters following are all creating the attributes we can set.
We can set any number of parameters we wish, in this example we define two.
The `:armour` parameter is being created without a default, it will equal to `nil` when a new component is created, while `hp` will be equal to 100 when a component is created.
When defining attributes symbols should be used.
</code></pre>

<h3 id="creating-a-component-from-a-component-manager">Creating a Component from a Component Manager</h3>

<pre class="code ruby"><code class="ruby">Now that we have a component manager we can make components from it like so:

```ruby
@component = FelECS::Components::Stats.new
```

Or we can even override the defaults when creating the component:

```ruby
@component = FelECS::Components::Stats.new(armour: &#39;steel&#39;)
```
</code></pre>

<h3 id="accessing">Accessing</h3>

<pre class="code ruby"><code class="ruby">You can access components using any array method.

```ruby
@component = FelECS::Components::Stats[2]
@component = FelECS::Components::Stats.first
@component = FelECS::Components::Stats.each # you can use iterators this way
```
</code></pre>

<h3 id="accessing-attributes-and-changing-them">Accessing Attributes and Changing Them</h3>

<pre class="code ruby"><code class="ruby">There are a few different ways we can read or change the attributes of a component depending on what our needs are.
Here are the ways to edit attrubutes, followed by the ways to read them.
```ruby
@component.armour = &#39;Mythril&#39;
@component.update_attrs(armour: &#39;Leather&#39;, hp: 95)
```
```ruby
@component.hp # =&gt; 95
@component.to_h # =&gt; {armour: &#39;Leather&#39;, hp: 95}
```
</code></pre>

<h3 id="deleting-components">Deleting Components</h3>

<pre class="code ruby"><code class="ruby">Deleting a Component is the same convention as deleting an Entity. When a Component is deleted referenced to it such as to entities are automatically cleared.

```ruby
@component.delete
```
</code></pre>

<h3 id="accessing-components-attached-entities">Accessing Components&#39; attached Entities</h3>

<pre class="code ruby"><code class="ruby">Components also keep track of what Entities are using it. To access this list we do the following:

```ruby
@component.entities # =&gt; [@entity1, @entity2, @entity3]
</code></pre>

<h1 id="get-the-first-entity-attached">get the first entity attached.</h1>

<h1 id="this-will-throw-a-warning-if-there-is-more-or-less-then">this will throw a warning if there is more or less then</h1>

<h1 id="exactly-one-entity">exactly one entity</h1>

<pre class="code ruby"><code class="ruby">@component.entity # =&gt; @entity
```
</code></pre>

<h2 id="systems">Systems</h2>

<h3 id="creation">Creation</h3>

<pre class="code ruby"><code class="ruby">We can create Systems like so:

```ruby
FelECS::Systems.new(&#39;Render&#39;, priority: 2) do
</code></pre>

<h1 id="code-and-logic">Code and Logic</h1>

<pre class="code ruby"><code class="ruby">end
```

The name we assign is how we can access the System, like so:

```ruby
FelECS::Systems::Render
```
Priority determines the order Systems should be executed, this is used for `Scenes` and the `Stage`.
The lower the number, the earlier a given System will be executed.
E.g priority 1 will go first, priority 2 will go second, etcetera. 

Both Scenes and Systems have a priority. System priority will decide the order it will be called inside of a Scene, which the Scene priority will decide the order it will be called inside of the Stage.

Often we will want to execute some logic on each Component in a given Component Manager so our code might look like this:

```ruby
FelECS::Systems.new(&#39;Render&#39;, priority: 2) do
FelECS::Components::Sprites.each do |component|
</code></pre>

<h1 id="do-something-with-these-components">do something with these components</h1>

<pre class="code ruby"><code class="ruby">end
end
```
</code></pre>

<h3 id="execution">Execution</h3>

<pre class="code ruby"><code class="ruby">After we create a System, it won&#39;t do anything on its own until we tell it to. Here is how:

```ruby
FelECS::Systems::Render.call
```

Sometimes you might want to manually activate a System, but the more common way to have Systems be triggered is to use Scenes and the Stage or the alternative ways of execution.
</code></pre>

<h3 id="alternative-execution">Alternative Execution</h3>

<pre class="code ruby"><code class="ruby">Sometimes you want a System to automatically trigger when a special even happens. FelECS can keep track of when a Component is added, removed, or when an attribute is changed and then execute Systems linked to these events. Here is how to create these links:

```ruby
</code></pre>

<h1 id="when-this-component-is-added-to-an-entity-this-system-will-be-called">When this Component is added to an Entity, this System will be called</h1>

<p>FelECS::Systems::PassiveRegen.trigger_when_added(@component)</p>

<h1 id="when-this-component-is-removed-from-an-entity-this-system-will-be-called">When this Component is removed from an Entity, this System will be called</h1>

<p>FelECS::Systems::PassiveRegen.trigger_when_removed(@component)</p>

<h1 id="when-this-components-health-attribute-is-changed-this-system-will-be-called">When this Component&#39;s health attribute is changed, this System will be called</h1>

<p>FelECS::Systems::PassiveRegen.trigger_when_is_set(@component, :health)
    ```</p>

<pre class="code ruby"><code class="ruby">If we want these triggers to happen for all Components that belong to specific Component Manager then we can do that instead:

```ruby
</code></pre>

<h1 id="when-a-component-from-this-component-manager-is-added-to-an-entity-this-system-will-be-called">When a Component from this Component Manager is added to an Entity, this System will be called</h1>

<p>FelECS::Systems::PassiveRegen.trigger_when_added(@component_manager)</p>

<h1 id="when-a-component-from-this-component-manager-is-removed-from-an-entity-this-system-will-be-called">When a Component from this Component Manager is removed from an Entity, this System will be called</h1>

<p>FelECS::Systems::PassiveRegen.trigger_when_removed(@component_manager)</p>

<h1 id="when-this-components-health-attribute-from-this-component-manager-is-changed-this-system-will-be-called">When this Component&#39;s health attribute from this Component Manager is changed, this System will be called</h1>

<p>FelECS::Systems::PassiveRegen.trigger_when_is_set(@component_manager, :health)
    ```</p>

<pre class="code ruby"><code class="ruby">We can create any number of these links between Systems, Components, and Component Manangers as we like, simply call the method again with our other Components and Component Managers
</code></pre>

<h3 id="clearing-alternative-executions">Clearing Alternative Executions</h3>

<pre class="code ruby"><code class="ruby">If we wish to remove these links that we created, we can do that using the follwing function in any of the following ways:

```ruby
</code></pre>

<h1 id="clears-all-triggers-with-this-system">clears ALL triggers with this system</h1>

<pre class="code ruby"><code class="ruby"><span class='const'>FelECS</span><span class='op'>::</span><span class='const'>Systems</span><span class='op'>::</span><span class='const'>PassiveRegen</span><span class='period'>.</span><span class='id identifier rubyid_clear_triggers'>clear_triggers</span>
</code></pre>

<h1 id="clears-all-triggers-with-this-component-manager">clears ALL triggers with this Component Manager</h1>

<p>FelECS::Systems::PassiveRegen.clear_triggers(@component)</p>

<h1 id="clear-the-trigger_when_added-for-this-component">clear the &#39;trigger_when_added&#39; for this Component</h1>

<p>FelECS::Systems::PassiveRegen.clear_triggers(@component, :added)</p>

<h1 id="clear-the-trigger_when_removed-for-this-component">clear the &#39;trigger_when_removed&#39; for this Component</h1>

<p>FelECS::Systems::PassiveRegen.clear_triggers(@component, :removed)</p>

<h1 id="clear-the-trigger_when_is_set-for-this-component-specifically-for-the-health-attribute">clear the &#39;trigger_when_is_set&#39; for this Component specifically for the health attribute</h1>

<p>FelECS::Systems::PassiveRegen.clear_triggers(@component, :is_set, :health)
    ```</p>

<pre class="code ruby"><code class="ruby">Likewise we can do the same with Component Managers:

```ruby
</code></pre>

<h1 id="clears-all-triggers-with-this-component">clears ALL triggers with this Component</h1>

<p>FelECS::Systems::PassiveRegen.clear_triggers(@component_manager) </p>

<h1 id="clear-the-trigger_when_added-for-this-component-manager">clear the &#39;trigger_when_added&#39; for this Component Manager</h1>

<p>FelECS::Systems::PassiveRegen.clear_triggers(@component_manager, :added) </p>

<h1 id="clear-the-trigger_when_removed-for-this-component-manager">clear the &#39;trigger_when_removed&#39; for this Component Manager</h1>

<p>FelECS::Systems::PassiveRegen.clear_triggers(@component_manager, :removed) </p>

<h1 id="clear-the-trigger_when_is_set-for-this-component-manager-specifically-for-the-health-attribute">clear the &#39;trigger_when_is_set&#39; for this Component Manager specifically for the health attribute</h1>

<p>FelECS::Systems::PassiveRegen.clear_triggers(@component_manager, :is_set, :health) 
    ```</p>

<h3 id="redefinition">Redefinition</h3>

<pre class="code ruby"><code class="ruby">If we wanted to change what code or logic a given System executes, we could do that with:

```ruby
FelECS::Systems::PassiveRegen.redefine do
</code></pre>

<h1 id="some-new-logic-or-code">Some new logic or code</h1>

<pre class="code ruby"><code class="ruby">end
```
</code></pre>

<h2 id="scenes">Scenes</h2>

<h3 id="creation">Creation</h3>

<pre class="code ruby"><code class="ruby">Once we have all the core parts of ECS, we will want to organize our Systems. To do this we will use Scenes to group up Systems so they can quickly be enabled or disabled. Note that [Alternative Executions](#alternative-execution) will occur even if they are not part of a Scene. Here is how we make a new Scene:

```ruby
@scene = FelECS::Scenes.new(&#39;ExampleScene&#39;, priority: 5)
```
</code></pre>

<h3 id="accessing">Accessing</h3>

<pre class="code ruby"><code class="ruby">Just like other classes in FelECS, the name we gave the Scene is how we access it:

```ruby
@scene = FelECS::Scenes::ExampleScene
```
</code></pre>

<h3 id="adding-systems">Adding Systems</h3>

<pre class="code ruby"><code class="ruby">Adding Systems is simple. We can add as many as we want. In this example we add 3 different systems:

```ruby
</code></pre>

<p>FelECS::Scenes::ExampleScene.add(
        FelECS::Systems::Render,
        @system2,
        @system3
        )
    ```</p>

<h3 id="removing-systems">Removing Systems</h3>

<pre class="code ruby"><code class="ruby">Removing Systems works similarly:

```ruby
</code></pre>

<p>FelECS::Scenes::ExampleScene.remove(
        FelECS::Systems::Render,
        @system2,
        @system3
        )
    ```</p>

<h3 id="clearing">Clearing</h3>

<pre class="code ruby"><code class="ruby">If you want to remove all Systems from a Scene here is how we do it:

```ruby
@scene.clear
```
</code></pre>

<h3 id="execution">Execution</h3>

<pre class="code ruby"><code class="ruby">To execute all Systems within a scene once we can just do:

```ruby
@scene.call
```

The Scene will make sure that the systems are executed in the correct order based on their given priorities
</code></pre>

<h2 id="stage">Stage</h2>

<h3 id="adding-scenes">Adding Scenes</h3>

<pre class="code ruby"><code class="ruby">Finally we have the Stage. There is only a single Stage and we do not have to create it as it exists by default. By adding a Scene to the Stage we are saying that the Scene is &#39;active&#39;. To add a Scene we do the following:

```ruby
FelECS::Stage.add FelECS::Scene::ExampleScene
```
</code></pre>

<h3 id="removing-scenes">Removing Scenes</h3>

<pre class="code ruby"><code class="ruby">Likewise we can remove Scenes:

```ruby
FelECS::Stage.remove FelECS::Scene::ExampleScene
```
</code></pre>

<h3 id="executing">Executing</h3>

<pre class="code ruby"><code class="ruby">On each frame of the game generally we will want to execute the Stage once. When the Stage is executed it is progressing your game 1 frame forward. The Stage will call all Scenes you added to it in the order of their priority. Here is how we do it:

```ruby
FelECS::Stage.call
```
</code></pre>

<h2 id="order">Order</h2>

<h3 id="setting-the-order">Setting the order</h3>

<pre class="code ruby"><code class="ruby">To set the order you just need to call `FelECS::Order.sort` and pass Scenes or Systems in the parameters in the order you wish for them to execute

```ruby
</code></pre>

<p>FelECS::Order.sort(
        @system1,
        @system2,
        @system3
        )
    ```</p>

<pre class="code ruby"><code class="ruby">If you want some Scenes or Systems to have the same priority then just pass them as an array:

```ruby
</code></pre>

<p>FelECS::Order.sort(
        @scene1,
        [@scene2_1, @scene2_2],
        @scene3
        ) 
    ```</p>

<h2 id="closing-notes">Closing Notes</h2>

<pre class="code ruby"><code class="ruby">There are some methods I haven&#39;t gone over in the overview. If you want to see everything and read in more detail check out the [Documentation](https://felflame.tradam.fyi)!
</code></pre>

<h1 id="contribution">Contribution</h1>

<pre class="code ruby"><code class="ruby">Contributors are welcome! I am always looking to impove the capabilities of game development in Ruby. Feel free to open an issue to discuss a proposed changed or fix. To code a change or fix first fork the project. Next write your changes or fixes. Make sure all your changes and fixes are properly documented using Yard(I will not merge if it is not 100% documented) and make sure everything has tests written for it with Rspec(I will also not merge if it does not have 100% test coverage). Once you have your changes made then simply make a pull request.  

If you need help writing documentation or tests feel free to ask!  

If you want to contribute to development with a thanks you can always [buy me a coffee ;^)](https://ko-fi.com/tradam)
</code></pre>
</div></div>

      <div id="footer">
  Generated on Thu Jan 20 22:40:31 2022 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.26 (ruby-2.7.3).
</div>

    </div>
  </body>
</html>